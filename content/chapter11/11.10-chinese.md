#11.10 优化数据搬运

随着处理器的发展，执行的速度是越来越快，计算能力也逐渐不再是高性能系统的主要瓶颈。取而代之的，对于数据敏感的计算来说，其主要瓶颈是在内存带宽上。在很多例子中，数据在主机端和加速器间的搬运时间，要远远大于其计算所消耗的时间。为了最小化这段开销，OpenCL为加速器提供了多种创建内存对象的方法。OpenCL中`CL_MEM_READ_ONLY`索引就代表了这段内存不能在计算时进行修改。如果使用这个索引创建的内存对象，需要在其中放置一些常量数据，这些数据在计算完成后也不需要拷贝回主机。与之相反，`CL_MEM_WRITE_ONLY`索引所创建的内存，大多数情况下是用来存放结果数据的。如果使用这个索引创建出的内存对象，不需要在加速器计算之前拷贝数据到这个内存当中。要将`C++ AMP`与OpenCL这些特性对应起来，我们就可以对应用的性能进行提升

##11.10.1 discard_data()

`C++ AMP`中discard_data()是array_view的一个成员函数。在运行时调用这个函数会将对应对象上的数据进行复写，因此就没有必要在计算开始之前，将数据拷贝到设备端。这种情况下，我们可以使用`CL_MEM_WRITE_ONLY`创建一个内存对象。

##11.10.2 `array_view<const T, N>`

如果一个array_view对象的第一个模板参数的限定符是const，那么我们只能通过`CL_MEM_READ_ONLY`创建相应的内存对象。这样的话，OpenCL运行时就能知道，哪端内存在计算的时候不能够被修改。因此，这个内存对象上所存储的数据，在计算完成后不需要拷贝回主机。
